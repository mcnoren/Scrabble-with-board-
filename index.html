<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Scrabble Pro - Universal</title>
    
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>

    <style>
        :root {
            --bg: #1a1a1a;
            --panel: #2c3e50;
            --accent: #27ae60;
            --accent-hover: #2ecc71;
            --danger: #c0392b;
            --warning: #f39c12;
            --info: #3498db;
            
            --wood-frame: #5d4037;
            --rack-color: #d2b48c; 
            --rack-shadow: #8d6e63;
            
            --tile-face: #fdf5e6;
            --tile-shadow: #bcaaa4;
            --tile-active: #f1c40f;
            --tile-blank-text: #c0392b;
            
            --board-bg: #d7ccc8;
            --text-main: #ecf0f1;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; font-family: 'Segoe UI', Roboto, sans-serif; background: var(--bg); color: var(--text-main); height: 100vh; overflow: hidden; display: flex; flex-direction: column; }

        .screen { display: none; width: 100%; height: 100%; position: absolute; top:0; left:0; background: var(--bg); z-index: 10; overflow-y: auto; flex-direction: column; }
        .active { display: flex; z-index: 20; }
        .center-screen { align-items: center; justify-content: center; text-align: center; }

        input { padding: 15px; font-size: 1.2rem; border-radius: 8px; border: 2px solid #444; background: #333; color: white; margin-bottom: 12px; text-align: center; width: 280px; }
        button { background: var(--accent); color: white; border: none; padding: 16px 32px; font-size: 1.1rem; border-radius: 8px; cursor: pointer; margin: 10px; font-weight: 600; box-shadow: 0 4px 0 rgba(0,0,0,0.2); transition: transform 0.1s; }
        button:active { transform: translateY(2px); box-shadow: none; }
        button:disabled { background: #444; color: #888; cursor: not-allowed; transform: none; box-shadow: none; opacity: 0.6; }
        .btn-secondary { background: #7f8c8d; }
        .btn-warning { background: var(--warning); color: #222; }
        .btn-danger { background: var(--danger); color: white; }
        .btn-info { background: var(--info); color: white; }
        .btn-sm { padding: 8px 15px; font-size: 0.85rem; width: auto; margin: 0; }
        .btn-kick { padding: 4px 8px; font-size: 0.7rem; background: var(--danger); margin-left: 10px; }
        .btn-resync { padding: 4px 8px; font-size: 0.7rem; background: #3498db; margin-left: 5px; color: white; border-radius: 4px; border:none; cursor: pointer; }
        
        .close-icon-btn { background: transparent; border: none; font-size: 1.5rem; color: #aaa; cursor: pointer; padding: 0 10px; box-shadow:none; margin:0; }

        /* SCROLLABLE LISTS */
        .session-list { margin-top: 10px; width: 320px; max-height: 250px; overflow-y: auto; background: rgba(255,255,255,0.05); border-radius: 8px; border: 1px solid #444; }
        .session-item { display: flex; justify-content: space-between; align-items: center; padding: 12px; border-bottom: 1px solid #444; font-size: 0.9rem; text-align: left; }
        .session-item:last-child { border-bottom: none; }
        .session-info { display: flex; flex-direction: column; gap: 2px; }
        .session-code { font-weight: bold; color: var(--accent); letter-spacing: 1px; font-size: 1.1rem; }
        .session-meta { color: #95a5a6; font-size: 0.75rem; }

        /* BOARD GRID */
        /* Adjusted for responsiveness on mobile player view */
        .board-wrapper { flex-grow: 1; height: 100%; display: flex; align-items: center; justify-content: center; background: #111; position: relative; overflow: hidden; }
        .scrabble-board { display: grid; grid-template-columns: repeat(15, 1fr); grid-template-rows: repeat(15, 1fr); gap: 1px; background: #000; border: 4px solid var(--wood-frame); border-radius: 4px; width: 98vmin; height: 98vmin; box-shadow: 0 0 20px rgba(0,0,0,0.5); touch-action: none; }
        
        /* Mobile adjustment for board */
        @media (max-width: 600px) {
            .scrabble-board { width: 95vw; height: 95vw; margin-top: 50px; }
            .board-wrapper { align-items: flex-start; padding-top: 10px; }
        }

        .cell { background: var(--board-bg); display: flex; justify-content: center; align-items: center; font-size: 0.55rem; font-weight: 800; color: #666; position: relative; text-transform: uppercase; user-select: none; }
        .tw { background: #ff7675; color: white; } .dw { background: #fab1a0; color: #444; }
        .tl { background: #74b9ff; color: white; } .dl { background: #81ecec; color: #444; }
        .star { background: #fab1a0; font-size: 1.2rem; color: #d63031; }

        /* TILES */
        .tile { width: 100%; height: 100%; background: var(--tile-face); border-radius: 2px; box-shadow: inset 0 -2px 0 rgba(0,0,0,0.2), 0 1px 2px rgba(0,0,0,0.2); color: #2d3436; display: flex; justify-content: center; align-items: center; font-weight: 700; font-size: 1.1rem; position: relative; cursor: grab; z-index: 20; touch-action: none; }
        .cell .tile { position: absolute; top:0; left:0; width:100%; height:100%; z-index: 30; font-size: 0.9rem; }
        .tile[data-new="true"] { background: var(--tile-active); box-shadow: inset 0 -2px 0 #d4a017; color: #000; }
        .tile span.score { font-size: 0.4rem; position: absolute; bottom: 1px; right: 1px; font-weight: 600; }
        .tile.dragging { position: fixed; z-index: 99999; width: 40px !important; height: 40px !important; opacity: 0.9; pointer-events: none; box-shadow: 0 10px 20px rgba(0,0,0,0.4); border: 2px solid var(--accent); margin: 0; }
        .tile.is-blank-assigned { color: var(--tile-blank-text); }

        /* PLAYER/PASS & PLAY UI */
        #player-ui, #pass-play-ui { background: #1a1a1a; }
        .player-hud { position: fixed; top: 0; left: 0; width: 100%; display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; background: rgba(0,0,0,0.9); z-index: 100; border-bottom: 1px solid #333; height: 50px; }
        .hud-name { font-weight: bold; color: #fff; font-size: 1rem; }
        .hud-status { font-size: 0.8rem; color: #ccc; background: rgba(255,255,255,0.1); padding: 4px 10px; border-radius: 12px; }
        .hud-status.active { background: var(--accent); color: white; }

        .rack-container { position: fixed; bottom: 0; left: 0; width: 100%; background: #222; padding: 10px; border-top: 1px solid #444; z-index: 200; display: flex; flex-direction: column; gap: 10px; align-items: center; }
        .player-rack { background: var(--rack-color); padding: 10px; border-radius: 6px; display: inline-flex; justify-content: center; gap: 4px; border-bottom: 6px solid var(--rack-shadow); min-height: 55px; min-width: 280px; }
        .player-rack .tile { width: 40px; height: 40px; font-size: 1.2rem; }
        .controls-row { display: flex; gap: 8px; width: 100%; max-width: 500px; justify-content: center; }
        .controls-row button { margin: 0; padding: 10px; font-size: 0.9rem; flex: 1; }

        /* INTERSTITIAL (PASS DEVICE) SCREEN */
        #screen-pass-interstitial { background: var(--panel); color: white; z-index: 3000; }
        
        /* OVERLAYS */
        #notification-overlay, #blank-overlay, #confirm-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9000; display: none; align-items: center; justify-content: center; backdrop-filter: blur(5px); }
        .modal { background: #2c3e50; border: 1px solid #444; padding: 25px; border-radius: 12px; text-align: center; max-width: 320px; box-shadow: 0 20px 50px rgba(0,0,0,0.6); color: white; }
        #blank-selector { display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; margin-top: 10px; max-width: 300px; }
        .letter-btn { width: 35px; height: 35px; background: var(--tile-face); border: none; border-radius: 3px; color: #2d3436; font-weight: 700; font-size: 1rem; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; }

        #score-pill { position: fixed; top: 60px; left: 50%; transform: translateX(-50%); background: #2980b9; color: white; padding: 8px 18px; border-radius: 30px; font-weight: 800; font-size: 1.1rem; box-shadow: 0 5px 15px rgba(0,0,0,0.4); pointer-events: none; z-index: 2000; opacity: 0; transition: opacity 0.2s; }
        #score-pill.visible { opacity: 1; }
        
        /* HOST SPECIFIC UI (SIDEBAR) */
        #screen-host { flex-direction: row; }
        .sidebar { width: 300px; height: 100%; background: var(--panel); border-right: 1px solid #444; display: flex; flex-direction: column; padding: 15px; z-index: 50; }
        .player-row { display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid #444; background: rgba(255,255,255,0.02); }
        .player-row.active-turn { border-left: 4px solid var(--accent); background: rgba(255,255,255,0.08); }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="blank-overlay"><div class="modal"><h3 style="margin-top:0;">Assign Blank</h3><div id="blank-selector"></div></div></div>
    
    <div id="confirm-overlay">
        <div class="modal">
            <h3 id="confirm-title" style="margin-top:0; color:#e74c3c;">Confirm</h3>
            <p id="confirm-msg" style="color:#bdc3c7; margin-bottom:20px; font-size:0.9rem;"></p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button id="btn-confirm-yes" class="btn-danger btn-sm" style="padding:10px 20px;">Yes</button>
                <button onclick="document.getElementById('confirm-overlay').style.display='none'" class="btn-secondary btn-sm" style="padding:10px 20px;">No</button>
            </div>
        </div>
    </div>

    <div id="notification-overlay" onclick="this.style.display='none'">
        <div class="modal" onclick="event.stopPropagation()">
            <h3 id="modal-title" style="margin-top:0;">Notice</h3>
            <p id="modal-msg" style="color:#bdc3c7; margin-bottom:20px; font-size:0.9rem;"></p>
            <button onclick="document.getElementById('notification-overlay').style.display='none'">OK</button>
        </div>
    </div>

    <div id="score-pill">0 pts</div>

    <div id="screen-home" class="screen active center-screen">
        <h1 style="font-size:3.5rem; margin-bottom:10px; color:#ecf0f1;">Scrabble<span style="color:var(--accent)">Pro</span></h1>
        <p style="color:#7f8c8d; margin-bottom:40px;">Universal Edition</p>
        
        <div style="display:flex; flex-direction:column; gap:15px; align-items: center;">
            <button onclick="showScreen('screen-pass-setup')" style="width:280px; background:#e67e22;">Local Pass & Play</button>
            <button onclick="initHost()" style="width:280px;">Host Online Game</button>
            <button onclick="showScreen('screen-join')" class="btn-secondary" style="width:280px;">Join Online Game</button>
        </div>
    </div>

    <div id="screen-pass-setup" class="screen center-screen">
        <h2>Pass & Play Setup</h2>
        <div id="pp-player-inputs">
            <input type="text" placeholder="Player 1 Name" class="pp-name">
            <input type="text" placeholder="Player 2 Name" class="pp-name">
        </div>
        <button onclick="addLocalPlayerInput()" class="btn-secondary btn-sm">+ Add Player</button>
        <br><br>
        <button onclick="startLocalGame()" style="width:280px;">Start Game</button>
        <button onclick="showScreen('screen-home')" class="btn-secondary">Back</button>
    </div>

    <div id="screen-pass-interstitial" class="screen center-screen">
        <h1 style="color:#bdc3c7;">Next Turn</h1>
        <h2 id="pp-next-name" style="color:var(--accent); font-size:3rem; margin:20px 0;">Player</h2>
        <p>Pass the device to the next player.</p>
        <button onclick="revealLocalTurn()" style="width:200px; margin-top:30px;">I am Ready</button>
    </div>

    <div id="screen-game" class="screen">
        <div class="player-hud">
            <div style="display:flex; align-items:center; gap:10px;">
                <button onclick="handleExit()" class="btn-danger btn-sm" style="margin:0; padding:5px 10px;">Exit</button>
                <div class="hud-name" id="game-hud-name">Player</div>
            </div>
            <div class="hud-status" id="game-hud-status">Waiting...</div>
        </div>
        
        <div class="board-wrapper">
            <div class="scrabble-board" id="game-board"></div>
        </div>

        <div class="rack-container">
            <div id="game-rack" class="player-rack"></div>
            <div class="controls-row">
                <button onclick="shuffleRack()" class="btn-secondary">Shuffle</button>
                <button onclick="actionSwap()" class="btn-warning">Swap</button>
                <button onclick="actionPass()" class="btn-secondary">Pass</button>
                <button id="btn-action-play" onclick="actionPlay()">PLAY</button>
            </div>
        </div>
    </div>

    <div id="screen-host" class="screen">
        <div class="sidebar">
            <h2 style="color:var(--accent);">Room <span id="host-room-code"></span></h2>
            <div style="font-size:0.8rem; color:#7f8c8d; margin-bottom:20px;">Share this code with players.</div>
            <div id="host-player-list" style="flex-grow:1; overflow-y:auto;"></div>
            <button onclick="endOnlineGame()" class="btn-danger" style="width:100%;">End Game</button>
        </div>
        <div class="board-wrapper">
            <div class="scrabble-board" id="host-board"></div>
        </div>
    </div>

    <div id="screen-join" class="screen center-screen">
        <h2>Join Game</h2>
        <input type="text" id="join-name" placeholder="Your Name" maxlength="12">
        <input type="text" id="join-code" placeholder="Room Code" maxlength="4" style="text-transform:uppercase;">
        <br>
        <button id="btn-join" onclick="joinGame()" style="width:280px;">Connect</button>
        <button onclick="showScreen('screen-home')" class="btn-secondary">Back</button>
        <div id="connect-status" style="color:#e74c3c; margin-top:15px;"></div>
    </div>

    <script>
        // --- CONSTANTS & DATA ---
        const SCORES = {'A':1,'B':3,'C':3,'D':2,'E':1,'F':4,'G':2,'H':4,'I':1,'J':8,'K':5,'L':1,'M':3,'N':1,'O':1,'P':3,'Q':10,'R':1,'S':1,'T':1,'U':1,'V':4,'W':4,'X':8,'Y':4,'Z':10,'_':0};
        const BAG_INIT = {'A':9,'B':2,'C':2,'D':4,'E':12,'F':2,'G':3,'H':2,'I':9,'J':1,'K':1,'L':4,'M':2,'N':6,'O':8,'P':2,'Q':1,'R':6,'S':4,'T':6,'U':4,'V':2,'W':2,'X':1,'Y':2,'Z':1,'_':2};
        const LAYOUT = [[1,0,0,4,0,0,0,1,0,0,0,4,0,0,1],[0,2,0,0,0,3,0,0,0,3,0,0,0,2,0],[0,0,2,0,0,0,4,0,4,0,0,0,2,0,0],[4,0,0,2,0,0,0,4,0,0,0,2,0,0,4],[0,0,0,0,2,0,0,0,0,0,2,0,0,0,0],[0,3,0,0,0,3,0,0,0,3,0,0,0,3,0],[0,0,4,0,0,0,4,0,4,0,0,0,4,0,0],[1,0,0,4,0,0,0,5,0,0,0,4,0,0,1],[0,0,4,0,0,0,4,0,4,0,0,0,4,0,0],[0,3,0,0,0,3,0,0,0,3,0,0,0,3,0],[0,0,0,0,2,0,0,0,0,0,2,0,0,0,0],[4,0,0,2,0,0,0,4,0,0,0,2,0,0,4],[0,0,2,0,0,0,4,0,4,0,0,0,2,0,0],[0,2,0,0,0,3,0,0,0,3,0,0,0,2,0],[1,0,0,4,0,0,0,1,0,0,0,4,0,0,1]];
        
        // --- GLOBAL STATE ---
        let mode = 'none'; // 'local' or 'online'
        let dictionary = new Set();
        let bag = [];
        let players = []; // {name, score, tiles:[], id, conn (if online)}
        let turnIndex = 0;
        let isFirstTurn = true;
        let pendingBlank = null;
        
        // Online Specific
        let peer, conn, myPeerId, hostCode;
        let isHost = false;
        
        // UI Drag Tracking
        let dragEl = null, clone = null;

        // --- INIT ---
        window.onload = () => {
            // Load Dictionary
            fetch('https://raw.githubusercontent.com/redbo/scrabble/master/dictionary.txt')
                .then(r=>r.text())
                .then(t => t.toUpperCase().split(/\s+/).forEach(w => dictionary.add(w)));
            
            // Generate Blank Selector
            const sel = document.getElementById('blank-selector');
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("").forEach(l => {
                const b = document.createElement('button');
                b.className = 'letter-btn'; b.innerText = l; b.onclick = () => assignBlank(l);
                sel.appendChild(b);
            });
        };

        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        function showModal(title, msg) {
            document.getElementById('modal-title').innerText = title;
            document.getElementById('modal-msg').innerText = msg;
            document.getElementById('notification-overlay').style.display = 'flex';
        }

        // --- SHARED GAME LOGIC ---

        function initBag() {
            bag = [];
            for(let l in BAG_INIT) for(let i=0; i<BAG_INIT[l]; i++) bag.push(l);
            // Shuffle
            for(let i=bag.length-1; i>0; i--){
                const j = Math.floor(Math.random()*(i+1));
                [bag[i],bag[j]] = [bag[j],bag[i]];
            }
        }

        function drawTiles(count) {
            const drawn = [];
            for(let i=0; i<count && bag.length>0; i++) drawn.push(bag.pop());
            return drawn;
        }

        // Renders the board. ID is target div id. 
        // If readOnly=true, drag events are disabled for existing tiles.
        function renderBoardState(targetId, gridState, isInteractive) {
            const b = document.getElementById(targetId);
            b.innerHTML = '';
            for(let r=0; r<15; r++){
                for(let c=0; c<15; c++){
                    const d = document.createElement('div');
                    d.className = 'cell'; d.dataset.r = r; d.dataset.c = c;
                    
                    // Background style
                    const t = LAYOUT[r][c];
                    if(t===1){d.classList.add('tw');d.innerText='TW'}
                    else if(t===2){d.classList.add('dw');d.innerText='DW'}
                    else if(t===3){d.classList.add('tl');d.innerText='TL'}
                    else if(t===4){d.classList.add('dl');d.innerText='DL'}
                    else if(t===5){d.classList.add('star');d.innerHTML='â˜…'}

                    // Tile Content
                    if(gridState && gridState[r][c]) {
                        const data = gridState[r][c];
                        const tile = createTileEl(data.letter, data.isBlank);
                        tile.dataset.locked = "true";
                        // If interactive, locked tiles block placement but aren't draggable
                        d.appendChild(tile);
                    }
                    b.appendChild(d);
                }
            }
        }

        function createTileEl(letter, isBlank=false, isNew=false) {
            const d = document.createElement('div');
            d.className = 'tile';
            d.dataset.letter = letter;
            if(isBlank) { 
                d.dataset.isBlank = "true"; 
                d.classList.add('is-blank-assigned');
            }
            if(isNew) d.dataset.new = "true";
            
            if(letter === '_') {
                 d.innerHTML = '';
            } else {
                 d.innerHTML = `${letter}<span class="score">${isBlank?0:SCORES[letter]}</span>`;
            }
            
            // Attach Drag Events
            d.onpointerdown = onDragStart;
            return d;
        }

        // --- LOCAL PASS & PLAY LOGIC ---

        function addLocalPlayerInput() {
            const div = document.getElementById('pp-player-inputs');
            if(div.children.length >= 4) return;
            const inp = document.createElement('input');
            inp.type = "text"; inp.className = "pp-name"; inp.placeholder = `Player ${div.children.length+1} Name`;
            div.appendChild(inp);
        }

        function startLocalGame() {
            const inputs = document.querySelectorAll('.pp-name');
            const names = Array.from(inputs).map(i => i.value.trim()).filter(n => n);
            if(names.length < 2) { showModal("Error", "Need at least 2 players."); return; }
            
            mode = 'local';
            initBag();
            players = names.map(n => ({ name: n, score: 0, tiles: drawTiles(7) }));
            turnIndex = 0;
            isFirstTurn = true;
            
            // Clear board state
            document.querySelectorAll('.cell').forEach(c => c.innerHTML = ''); // Should be re-rendered cleanly
            renderBoardState('game-board', null, true); // Empty board
            
            updateLocalUI();
        }

        function updateLocalUI() {
            // Show interstitial first
            const p = players[turnIndex];
            document.getElementById('pp-next-name').innerText = p.name;
            showScreen('screen-pass-interstitial');
        }

        function revealLocalTurn() {
            showScreen('screen-game');
            const p = players[turnIndex];
            document.getElementById('game-hud-name').innerText = p.name + ` (${p.score} pts)`;
            document.getElementById('game-hud-status').innerText = "YOUR TURN";
            document.getElementById('game-hud-status').classList.add('active');
            
            renderRack(p.tiles);
            // Ensure board has correct locked state from memory (scraped from DOM in local mode or persisted variable?)
            // In local mode, we can just rely on the DOM if we don't reload. 
            // Better: Keep a grid variable.
        }

        function renderRack(tiles) {
            const r = document.getElementById('game-rack');
            r.innerHTML = '';
            tiles.forEach(l => {
                const t = createTileEl(l, false, true); // treated as "new" so it is draggable
                // Actually, rack tiles shouldn't have data-new="true" for board scoring logic yet, 
                // but our drag logic adds data-new when dropped on board.
                delete t.dataset.new; 
                r.appendChild(t);
            });
        }

        // --- ACTION HANDLERS (Shared UI) ---

        function actionPass() {
            if(!confirm("Pass turn?")) return;
            endTurnLocal(0);
        }

        function actionSwap() {
            // In local mode, we need a UI to select tiles to swap. 
            // For simplicity in this implementation: Swap ALL tiles logic or Drag to specific zone?
            // Let's implement "Recall all to rack" then "Click to select for swap".
            // Simplifying: Swap requires empty board.
            const placed = document.querySelectorAll('#game-board .tile[data-new="true"]');
            if(placed.length > 0) { showModal("Error", "Recall tiles before swapping."); return; }
            
            if(bag.length < 7) { showModal("Error", "Bag empty."); return; }
            
            // Simple swap: Swap whole rack for now to save UI complexity, or swap random 7.
            // Let's just swap all.
            if(!confirm("Swap your rack? Turn will end.")) return;
            
            const p = players[turnIndex];
            bag.push(...p.tiles);
            // Shuffle
            for(let i=bag.length-1; i>0; i--){
                const j = Math.floor(Math.random()*(i+1));
                [bag[i],bag[j]] = [bag[j],bag[i]];
            }
            p.tiles = drawTiles(7);
            endTurnLocal(0);
        }

        function actionPlay() {
            const newTiles = Array.from(document.querySelectorAll('#game-board .tile[data-new="true"]'));
            if(newTiles.length === 0) return;
            
            // Validation
            if(isFirstTurn) {
                const hasCenter = newTiles.some(t => {
                    const p = t.parentElement;
                    return parseInt(p.dataset.r)===7 && parseInt(p.dataset.c)===7;
                });
                if(!hasCenter) { showModal("Error", "First word must cover center star."); return; }
            }

            // Check Connectivity & Alignment
            if(!validatePlacement(newTiles)) { showModal("Invalid", "Tiles must be in a straight line and connected."); return; }

            // Calculate Score & Check Words
            const score = calculateScore(newTiles); // This also validates words against dictionary
            if(score === -1) { showModal("Invalid Word", "A word formed is not in dictionary."); return; }

            // --- EXECUTE MOVE ---
            if(mode === 'local') {
                // Apply score
                players[turnIndex].score += score;
                
                // Lock tiles
                newTiles.forEach(t => {
                    t.removeAttribute('data-new');
                    t.dataset.locked = "true";
                });
                
                // Update Rack (remove used tiles)
                const usedIds = newTiles.map(t => t.dataset.letter); // Simplified: Local mode doesn't track IDs strictly, just letters.
                // Issue: If I have two 'A's, which one did I use?
                // Fix: In renderRack, give them DOM IDs or just remove by letter count.
                // Removal Logic:
                const rack = players[turnIndex].tiles;
                newTiles.forEach(t => {
                    const l = t.dataset.letter; // Note: Blanks are '_' in rack
                    // If t is blank assigned, original was '_'.
                    // We need to know if the tile source was a blank.
                    // The drag element dataset should help.
                    // Simplified: We check if t.classList contains 'is-blank-assigned'.
                    const search = t.classList.contains('is-blank-assigned') ? '_' : l;
                    const idx = rack.indexOf(search);
                    if(idx > -1) rack.splice(idx, 1);
                });
                
                // Draw new
                const needed = 7 - rack.length;
                rack.push(...drawTiles(needed));
                
                isFirstTurn = false;
                endTurnLocal(score);
            } else if (mode === 'online') {
                // Send Move to Host
                // Structure: { r, c, letter, isBlank }
                const moves = newTiles.map(t => ({
                    r: parseInt(t.parentElement.dataset.r),
                    c: parseInt(t.parentElement.dataset.c),
                    letter: t.dataset.letter,
                    isBlank: t.classList.contains('is-blank-assigned')
                }));
                
                conn.send({ type: 'play_move', moves: moves });
                // We wait for host confirmation to unlock UI
            }
        }

        function endTurnLocal(lastScore) {
            turnIndex = (turnIndex + 1) % players.length;
            updateLocalUI();
        }

        function handleExit() {
            if(confirm("Exit game?")) {
                if(conn) conn.close();
                location.reload();
            }
        }

        // --- ONLINE LOGIC ---

        function initHost() {
            isHost = true;
            mode = 'online';
            players = [];
            initBag();
            
            const code = generateCode();
            peer = new Peer(code);
            
            peer.on('open', (id) => {
                hostCode = id;
                document.getElementById('host-room-code').innerText = id;
                showScreen('screen-host');
                renderBoardState('host-board', null, false);
            });
            
            peer.on('connection', c => {
                c.on('data', d => handleHostData(c, d));
                c.on('close', () => { /* Handle disconnect */ });
            });
        }

        function joinGame() {
            const name = document.getElementById('join-name').value.trim();
            const code = document.getElementById('join-code').value.trim().toUpperCase();
            if(!name || code.length!==4) return;
            
            mode = 'online';
            isHost = false;
            document.getElementById('btn-join').innerText = "Connecting...";
            
            peer = new Peer();
            peer.on('open', id => {
                conn = peer.connect(code);
                conn.on('open', () => {
                    conn.send({ type: 'join', name: name });
                });
                conn.on('data', d => handleClientData(d));
                conn.on('error', e => alert("Connection Error"));
            });
        }

        // Host Handling
        function handleHostData(c, data) {
            if(data.type === 'join') {
                const newP = { 
                    id: c.peer, 
                    conn: c, 
                    name: data.name, 
                    score: 0, 
                    tiles: drawTiles(7) 
                };
                players.push(newP);
                updateHostPlayerList();
                
                // Sync new player
                c.send({ 
                    type: 'welcome', 
                    tiles: newP.tiles, 
                    grid: getGridState(),
                    players: players.map(p => ({name:p.name, score:p.score}))
                });
            }
            if(data.type === 'play_move') {
                // 1. Apply to temporary grid to validate
                // 2. Broadcast if valid
                const p = players.find(x => x.id === c.peer);
                if(!p) return;
                
                // Server-side validation (simplified here: trust client validation + basic overlap check)
                const grid = getGridState();
                
                // Update Grid
                data.moves.forEach(m => {
                    // Update master grid (DOM on host)
                    const cell = document.querySelector(`#host-board .cell[data-r="${m.r}"][data-c="${m.c}"]`);
                    cell.innerHTML = '';
                    const t = createTileEl(m.letter, m.isBlank);
                    t.dataset.locked = "true";
                    cell.appendChild(t);
                });
                
                // Calculate Score (Host Logic)
                // We need to simulate the placement to score it. 
                // For this demo, we assume client score is correct or recalculate.
                // Let's recalculate simply based on moves.
                const newTiles = data.moves.map(m => {
                    const cell = document.querySelector(`#host-board .cell[data-r="${m.r}"][data-c="${m.c}"]`);
                    return cell.querySelector('.tile'); // reusing client-side calc logic by querying host DOM
                });
                // Note: The calc function relies on "data-new" which we didn't set on host.
                // Hack: Set data-new temporarily
                newTiles.forEach(t => t.dataset.new = "true");
                const score = calculateScore(newTiles); // This uses Host DOM
                newTiles.forEach(t => { delete t.dataset.new; t.dataset.locked="true"; });
                
                p.score += score;
                
                // Remove tiles from rack
                data.moves.forEach(m => {
                    const char = m.isBlank ? '_' : m.letter;
                    const idx = p.tiles.indexOf(char);
                    if(idx > -1) p.tiles.splice(idx, 1);
                });
                
                // Refill
                const needed = 7 - p.tiles.length;
                p.tiles.push(...drawTiles(needed));
                
                // Next turn
                isFirstTurn = false;
                turnIndex = (turnIndex + 1) % players.length;
                
                // Broadcast Update
                broadcastUpdate();
            }
        }

        function broadcastUpdate() {
            const grid = getGridState();
            const pList = players.map(p => ({name:p.name, score:p.score}));
            players.forEach((p, i) => {
                p.conn.send({
                    type: 'update',
                    grid: grid,
                    players: pList,
                    tiles: p.tiles, // Send updated rack
                    myTurn: (i === turnIndex)
                });
            });
            updateHostPlayerList();
        }

        // Client Handling
        function handleClientData(data) {
            if(data.type === 'welcome' || data.type === 'update') {
                showScreen('screen-game');
                renderBoardState('game-board', data.grid, true);
                renderRack(data.tiles);
                
                // Update Status HUD
                document.getElementById('game-hud-name').innerText = data.players.find(x => x.name === document.getElementById('join-name').value).name; // Self name
                
                if(data.myTurn) {
                    document.getElementById('game-hud-status').innerText = "YOUR TURN";
                    document.getElementById('game-hud-status').classList.add('active');
                    document.getElementById('btn-action-play').disabled = false;
                } else {
                    document.getElementById('game-hud-status').innerText = "WAITING";
                    document.getElementById('game-hud-status').classList.remove('active');
                    document.getElementById('btn-action-play').disabled = true;
                }
            }
        }

        function getGridState() {
            // Scrape Host DOM
            const g = [];
            for(let r=0; r<15; r++){
                g[r] = [];
                for(let c=0; c<15; c++){
                    const cell = document.querySelector(`#host-board .cell[data-r="${r}"][data-c="${c}"]`);
                    const t = cell.querySelector('.tile');
                    if(t) {
                        g[r][c] = { letter: t.dataset.letter, isBlank: t.dataset.isBlank==="true" };
                    } else {
                        g[r][c] = null;
                    }
                }
            }
            return g;
        }

        function updateHostPlayerList() {
            const l = document.getElementById('host-player-list');
            l.innerHTML = players.map(p => `
                <div class="player-row">
                    <span>${p.name}</span>
                    <span style="font-weight:bold; color:var(--accent);">${p.score}</span>
                </div>
            `).join('');
        }

        // --- DRAG AND DROP SYSTEM ---
        
        function onDragStart(e) {
            // Prevent dragging locked tiles or if not my turn (if online logic enforces strict UI lock)
            if(e.currentTarget.dataset.locked === "true") return;
            
            e.preventDefault();
            dragEl = e.currentTarget;
            
            // If dragging blank back to rack, reset it
            if(dragEl.dataset.isBlank === "true") {
                // We keep the isBlank flag but might reset letter on drop if it goes to rack
            }

            clone = dragEl.cloneNode(true);
            clone.classList.add('dragging');
            document.body.appendChild(clone);
            
            moveClone(e.pageX, e.pageY);
            dragEl.style.opacity = '0';
            
            document.addEventListener('pointermove', onDragMove);
            document.addEventListener('pointerup', onDragEnd);
        }

        function onDragMove(e) {
            e.preventDefault();
            moveClone(e.pageX, e.pageY);
        }

        function onDragEnd(e) {
            document.removeEventListener('pointermove', onDragMove);
            document.removeEventListener('pointerup', onDragEnd);
            
            if(clone) { clone.remove(); clone = null; }
            if(dragEl) dragEl.style.opacity = '1';
            
            const el = document.elementFromPoint(e.clientX, e.clientY);
            if(!el) return;
            
            const cell = el.closest('.cell');
            const rack = el.closest('.player-rack');
            
            if(cell && !cell.querySelector('.tile')) {
                // Drop on Board
                if(dragEl.dataset.letter === '_') {
                    pendingBlank = dragEl;
                    document.getElementById('blank-overlay').style.display = 'flex';
                } else {
                    dragEl.dataset.new = "true";
                }
                cell.appendChild(dragEl);
            } else if (rack) {
                // Return to Rack
                delete dragEl.dataset.new;
                if(dragEl.dataset.isBlank === "true") {
                    dragEl.dataset.letter = '_';
                    dragEl.innerHTML = '';
                    dragEl.classList.remove('is-blank-assigned');
                }
                rack.appendChild(dragEl);
            }
            
            dragEl = null;
            updateScoreEstimate();
        }

        function moveClone(x, y) {
            if(clone) {
                clone.style.left = (x - 20) + 'px';
                clone.style.top = (y - 20) + 'px';
            }
        }

        function assignBlank(l) {
            if(pendingBlank) {
                pendingBlank.dataset.letter = l;
                pendingBlank.innerText = l;
                pendingBlank.dataset.isBlank = "true";
                pendingBlank.classList.add('is-blank-assigned');
                pendingBlank.dataset.new = "true";
                document.getElementById('blank-overlay').style.display = 'none';
                pendingBlank = null;
                updateScoreEstimate();
            }
        }

        // --- VALIDATION & SCORING ---

        function updateScoreEstimate() {
            const tiles = document.querySelectorAll('#game-board .tile[data-new="true"]');
            const pill = document.getElementById('score-pill');
            
            if(tiles.length === 0) { pill.classList.remove('visible'); return; }
            
            // Basic validity for showing score
            if(!validatePlacement(Array.from(tiles))) {
                 pill.innerText = "...";
                 pill.classList.add('visible');
                 return;
            }

            const pts = calculateScore(Array.from(tiles), true); // true = skip dictionary check for pill
            pill.innerText = `${pts} pts`;
            pill.classList.add('visible');
        }

        function validatePlacement(tiles) {
            if(tiles.length === 0) return false;
            // 1. Same Row or Col
            const coords = tiles.map(t => ({r: parseInt(t.parentElement.dataset.r), c: parseInt(t.parentElement.dataset.c)}));
            const rows = new Set(coords.map(x=>x.r));
            const cols = new Set(coords.map(x=>x.c));
            
            if(rows.size > 1 && cols.size > 1) return false;
            
            // 2. Continuous
            // Check gaps.
            if(rows.size === 1) {
                coords.sort((a,b) => a.c - b.c);
                const r = coords[0].r;
                for(let c=coords[0].c; c <= coords[coords.length-1].c; c++) {
                    const cell = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
                    if(!cell.querySelector('.tile')) return false;
                }
            } else {
                coords.sort((a,b) => a.r - b.r);
                const c = coords[0].c;
                for(let r=coords[0].r; r <= coords[coords.length-1].r; r++) {
                    const cell = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
                    if(!cell.querySelector('.tile')) return false;
                }
            }
            
            // 3. Connected to existing (unless first turn)
            if(!isFirstTurn) {
                let connected = false;
                coords.forEach(pos => {
                    const neighbors = [{r:1,c:0},{r:-1,c:0},{r:0,c:1},{r:0,c:-1}];
                    neighbors.forEach(n => {
                        const cell = document.querySelector(`.cell[data-r="${pos.r+n.r}"][data-c="${pos.c+n.c}"]`);
                        if(cell) {
                            const t = cell.querySelector('.tile');
                            if(t && t.dataset.locked === "true") connected = true;
                        }
                    });
                });
                if(!connected) return false;
            }
            
            return true;
        }

        function calculateScore(newTiles, skipDict=false) {
            let total = 0;
            const coords = newTiles.map(t=>({r:parseInt(t.parentElement.dataset.r),c:parseInt(t.parentElement.dataset.c)}));
            const isHoriz = new Set(coords.map(x=>x.r)).size === 1;
            
            // Primary Word
            const primary = getWordScore(coords[0].r, coords[0].c, isHoriz);
            total += primary.score;
            if(!skipDict && !dictionary.has(primary.word)) return -1;
            
            // Cross Words
            let valid = true;
            coords.forEach(pos => {
                const cross = getWordScore(pos.r, pos.c, !isHoriz);
                if(cross.word.length > 1) {
                    total += cross.score;
                    if(!skipDict && !dictionary.has(cross.word)) valid = false;
                }
            });
            
            if(!valid) return -1;
            if(newTiles.length === 7) total += 50;
            return total;
        }

        function getWordScore(r, c, isHoriz) {
            // Find start
            let curr = isHoriz ? c : r;
            while(curr > 0) {
                const cell = isHoriz ? getCell(r, curr-1) : getCell(curr-1, c);
                if(!cell.querySelector('.tile')) break;
                curr--;
            }
            const start = curr;
            
            // Find end
            curr = isHoriz ? c : r;
            while(curr < 14) {
                const cell = isHoriz ? getCell(r, curr+1) : getCell(curr+1, c);
                if(!cell.querySelector('.tile')) break;
                curr++;
            }
            const end = curr;
            
            let word = "";
            let score = 0;
            let mult = 1;
            
            for(let i=start; i<=end; i++) {
                const row = isHoriz ? r : i;
                const col = isHoriz ? i : c;
                const cell = getCell(row, col);
                const tile = cell.querySelector('.tile');
                
                let l = tile.dataset.letter;
                let val = (tile.dataset.isBlank === "true") ? 0 : SCORES[l];
                
                // Bonus
                if(tile.dataset.new === "true") {
                    const type = LAYOUT[row][col];
                    if(type===3) val*=3; // TL
                    else if(type===4) val*=2; // DL
                    
                    if(type===1) mult*=3; // TW
                    else if(type===2 || type===5) mult*=2; // DW
                }
                
                score += val;
                word += l;
            }
            
            if(word.length < 2) return { score: 0, word: "" };
            return { score: score * mult, word: word };
        }

        function getCell(r,c) { return document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`); }
        function shuffleRack() { const r = document.getElementById('game-rack'); Array.from(r.children).sort(()=>Math.random()-0.5).forEach(x=>r.appendChild(x)); }
        function generateCode() { return Math.random().toString(36).substring(2,6).toUpperCase(); }

    </script>
</body>
</html>
